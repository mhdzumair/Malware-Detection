import hashlib
import logging
import zipfile
from datetime import datetime
from io import BytesIO
from typing import List, Tuple, Optional

import boto3
import requests
from fastapi import HTTPException

from api.config import settings
from api.models import FileScan
from defender.feedback import get_virus_total_report
from defender.model import Model

model_data = {
    "deep_learning": "defender/saved_models/deep_learning.pkl",
    "random_forest": "defender/saved_models/random_forest.pkl",
}

models = {
    model_name: Model.load(model_path) for model_name, model_path in model_data.items()
}


def compute_file_hash(file_data: bytes, hash_type: str = "md5") -> str:
    """
    Computes the hash of a file

    :param file_data: the file data
    :param hash_type: the type of hash to compute
    :return: the hash of the file
    """

    h = hashlib.new(hash_type)
    h.update(file_data)
    return h.hexdigest()


async def get_external_tool_feedback(
    file_data: bytes, md5_file_hash: str
) -> Tuple[List, int]:
    """
    Gets the feedback from external tools

    :param file_data: the file data
    :param md5_file_hash: the md5 hash of the file
    :return: the feedback from external tools
    """
    feedback = []
    scan_result = None

    if settings.virus_total_api_key:
        vt_report = await get_virus_total_report(
            file_data,
            md5_file_hash,
            settings.virus_total_api_key,
        )
        if vt_report:
            feedback.append(vt_report)
            scan_result = 1 if vt_report.get("malicious") > 0 else 0
    else:
        raise ValueError("Virus Total API key not set")

    return feedback, scan_result


def download_file_from_url(url: str) -> bytes:
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.content
    except requests.RequestException as e:
        raise HTTPException(status_code=400, detail=str(e))


def extract_zip_file(file_content: bytes, password: Optional[str]) -> bytes:
    try:
        with zipfile.ZipFile(BytesIO(file_content)) as zip_file:
            zip_file.setpassword(password.encode() if password else None)
            file_info = zip_file.infolist()[0]
            return zip_file.read(file_info)
    except zipfile.BadZipFile:
        raise HTTPException(status_code=400, detail="Bad ZIP file.")
    except RuntimeError:
        raise HTTPException(status_code=400, detail="Incorrect ZIP password.")


def is_zip_file(file_content: bytes) -> bool:
    return file_content.startswith(b"PK")


async def fetch_file_data(
    file=None,
    file_url: str = None,
    s3_bucket: str = None,
    s3_path: str = None,
    zip_password: str = None,
) -> bytes:
    # Retrieve file content
    if file_url:
        file_data = download_file_from_url(file_url)
    elif file:
        file_data = await file.read()
    elif s3_bucket and s3_path:
        s3 = boto3.client("s3")
        try:
            file_data = s3.get_object(Bucket=s3_bucket, Key=s3_path)["Body"].read()
        except s3.exceptions.NoSuchKey:
            raise HTTPException(status_code=400, detail="File not found in S3")
    else:
        raise HTTPException(status_code=400, detail="No file or URL provided")

    # Check if the content is a ZIP file and extract if necessary
    if is_zip_file(file_data):
        file_data = extract_zip_file(file_data, zip_password)

    return file_data


async def perform_scan(
    file_data: bytes,
    known_status: Optional[int],
    external_tools: bool,
    force_rescan: bool,
):
    file_hash = compute_file_hash(file_data, "md5")

    # Check if file hash exists in DB
    file_scan = await FileScan.find_one(FileScan.md5_file_hash == file_hash)
    if file_scan and not force_rescan:
        return {
            "message": "File previously scanned",
            "md5_file_hash": file_scan.md5_file_hash,
            "deep_learning_result": file_scan.deep_learning_result,
            "random_forest_result": file_scan.random_forest_result,
            "external_tool_feedback": file_scan.external_tool_feedback,
            "known_status": file_scan.known_status,
            "scanned_at": file_scan.scanned_at,
        }

    # Scan with models
    try:
        dl_result = models["deep_learning"].predict_files([file_data]).item()
        rf_result = models["random_forest"].predict_files([file_data]).item()
    except Exception as error:
        logging.error(error)
        raise HTTPException(status_code=400, detail=f"Error scanning file: {error}")

    # Get feedback from external tools if requested
    external_feedback = None
    if external_tools:
        try:
            external_feedback, known_status = await get_external_tool_feedback(
                file_data, file_hash
            )
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Error getting external tool feedback. External tools not configured.",
            )

    if file_scan and force_rescan:
        file_scan.deep_learning_result = dl_result
        file_scan.random_forest_result = rf_result
        file_scan.external_tool_feedback = external_feedback
        file_scan.known_status = known_status
        file_scan.scanned_at = datetime.utcnow()
        await file_scan.save()
        return_message = "Scan updated"

    else:
        # Store new scan result
        file_scan = FileScan(
            md5_file_hash=file_hash,
            deep_learning_result=dl_result,
            random_forest_result=rf_result,
            external_tool_feedback=external_feedback,
            known_status=known_status,
        )
        await file_scan.insert()
        return_message = "Scan completed"

    return {
        "message": return_message,
        "md5_file_hash": file_scan.md5_file_hash,
        "deep_learning_result": file_scan.deep_learning_result,
        "random_forest_result": file_scan.random_forest_result,
        "external_tool_feedback": file_scan.external_tool_feedback,
        "known_status": file_scan.known_status,
        "scanned_at": file_scan.scanned_at,
    }


def send_notification(sns_topic_arn: str, message: str) -> None:
    """
    Sends a formatted notification message about the detection of malware.

    Args:
        sns_topic_arn: The ARN of the SNS topic to send the notification to.
        message: The message to send.
    """
    sns_client = boto3.client("sns")

    sns_client.publish(
        TopicArn=sns_topic_arn,
        Message=message,
        Subject="Malware Detection Alert",
    )


def delete_s3_file(bucket: str, key: str) -> None:
    """
    Deletes a file from S3.

    Args:
        bucket: The name of the S3 bucket.
        key: The name of the file to delete.
    """
    s3_client = boto3.client("s3")
    s3_client.delete_object(Bucket=bucket, Key=key)


def move_s3_file(bucket: str, key: str, destination_bucket: str) -> None:
    """
    Moves a file from one S3 bucket to another.

    Args:
        bucket: The name of the S3 bucket.
        key: The name of the file to move.
        destination_bucket: The name of the destination bucket.
    """
    s3_client = boto3.client("s3")
    s3_client.copy_object(
        Bucket=destination_bucket,
        CopySource={"Bucket": bucket, "Key": key},
        Key=key,
    )
    s3_client.delete_object(Bucket=bucket, Key=key)

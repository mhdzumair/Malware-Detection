import logging
from datetime import datetime
from typing import Literal, Optional

from fastapi import FastAPI, HTTPException, Depends, Query
from fastapi import UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

from api import authentication, database
from api import utils
from api.config import settings
from api.models import FileScan
from api.schemas import TokenData, Token
from defender.model import Model

logging.basicConfig(
    format="%(levelname)s::%(asctime)s - %(message)s",
    datefmt="%d-%b-%y %H:%M:%S",
    level=logging.INFO,
)
app = FastAPI(description="Malware Detection API")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="authentication")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.on_event("startup")
async def init_db():
    await database.init_db()


model_data = {
    "deep_learning": "defender/saved_models/deep_learning.pkl",
    "random_forest": "defender/saved_models/random_forest.pkl",
}

models = {
    model_name: Model.load(model_path) for model_name, model_path in model_data.items()
}


async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    username = authentication.get_current_user(token)
    if username is None:
        raise credentials_exception
    token_data = TokenData(username=username)

    user = await authentication.get_user(username=token_data.username)
    if user is None:
        raise credentials_exception
    return user


@app.get("/")
async def root():
    return {"message": "Malware Detection API"}


@app.post("/api/authentication", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    user = await authentication.authenticate_user(
        form_data.username, form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=401,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = authentication.create_access_token(
        data={"sub": user.user}, expires_delta=settings.access_token_expire
    )

    return Token(access_token=access_token, token_type="bearer")


@app.post("/api/scan")
async def scan(
    file: Optional[UploadFile] = None,
    file_url: Optional[str] = None,
    zip_password: Optional[str] = None,
    known_status: Optional[int] = Query(default=None, le=1, ge=0),
    external_tools: bool = None,
    force_rescan: bool = None,
    _=Depends(get_current_user),
):
    # Retrieve file content
    if file_url:
        file_data = utils.download_file_from_url(file_url)
    elif file:
        file_data = await file.read()
    else:
        raise HTTPException(status_code=400, detail="No file or URL provided")

    # Check if the content is a ZIP file and extract if necessary
    if utils.is_zip_file(file_data):
        file_data = utils.extract_zip_file(file_data, zip_password)

    file_hash = utils.compute_file_hash(file_data, "md5")

    # Check if file hash exists in DB
    file_scan = await FileScan.find_one(FileScan.md5_file_hash == file_hash)
    if file_scan and not force_rescan:
        return {
            "message": "File previously scanned",
            "md5_file_hash": file_scan.md5_file_hash,
            "deep_learning_result": file_scan.deep_learning_result,
            "random_forest_result": file_scan.random_forest_result,
            "external_tool_feedback": file_scan.external_tool_feedback,
            "known_status": file_scan.known_status,
            "scanned_at": file_scan.scanned_at,
        }

    # Scan with models
    try:
        dl_result = models["deep_learning"].predict_files([file_data]).item()
        rf_result = models["random_forest"].predict_files([file_data]).item()
    except Exception as error:
        logging.error(error)
        raise HTTPException(status_code=400, detail=f"Error scanning file: {error}")

    # Get feedback from external tools if requested
    external_feedback = None
    if external_tools:
        try:
            external_feedback, known_status = await utils.get_external_tool_feedback(
                file_data, file_hash
            )
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Error getting external tool feedback. External tools not configured.",
            )

    if file_scan and force_rescan:
        file_scan.deep_learning_result = dl_result
        file_scan.random_forest_result = rf_result
        file_scan.external_tool_feedback = external_feedback
        file_scan.known_status = known_status
        file_scan.scanned_at = datetime.utcnow()
        await file_scan.save()
        return_message = "Scan updated"

    else:
        # Store new scan result
        file_scan = FileScan(
            md5_file_hash=file_hash,
            deep_learning_result=dl_result,
            random_forest_result=rf_result,
            external_tool_feedback=external_feedback,
            known_status=known_status,
        )
        await file_scan.insert()
        return_message = "Scan completed"

    return {
        "message": return_message,
        "md5_file_hash": file_scan.md5_file_hash,
        "deep_learning_result": file_scan.deep_learning_result,
        "random_forest_result": file_scan.random_forest_result,
        "external_tool_feedback": file_scan.external_tool_feedback,
        "known_status": file_scan.known_status,
        "scanned_at": file_scan.scanned_at,
    }


@app.get("/api/scans")
async def list_scans(
    skip: int = 0,
    limit: int = Query(default=100, le=100, ge=1),
    _=Depends(get_current_user),
):
    total_count = await FileScan.count()
    scans = await FileScan.find().skip(skip).limit(limit).to_list()
    return {"items": scans, "total": total_count}


@app.get("/api/scans/{scan_id}")
async def get_scan(
    scan_id: str,
    _=Depends(get_current_user),
):
    scan_data = await FileScan.get(scan_id)
    if scan_data is None:
        raise HTTPException(status_code=404, detail="Scan not found")
    return scan_data


@app.get("/api/scan-results-summary/{model_type}")
async def get_scan_results_summary(
    model_type: Literal["random_forest", "deep_learning"],
    _=Depends(get_current_user),
):
    model_result_field = (
        FileScan.random_forest_result
        if model_type == "random_forest"
        else FileScan.deep_learning_result
    )

    # Fetch and aggregate data
    pipeline = [
        {
            "$group": {
                "_id": {
                    "known_status": "$known_status",
                    "model_result": f"${model_result_field}",
                },
                "count": {"$sum": 1},
            }
        }
    ]
    summary_data = await FileScan.aggregate(pipeline).to_list(length=None)

    # Transform to a more pie-chart-friendly format
    result_summary = {
        "benign_correct": 0,
        "benign_incorrect": 0,
        "malware_correct": 0,
        "malware_incorrect": 0,
        "unknown_benign": 0,
        "unknown_malware": 0,
        "total_scans": 0,
        "model_accuracy": "N/A",
    }

    for record in summary_data:
        known_status = record["_id"]["known_status"]
        model_result = record["_id"]["model_result"]
        count = record["count"]
        if known_status == 0:
            key = "benign_correct" if model_result == 0 else "benign_incorrect"
        elif known_status == 1:
            key = "malware_correct" if model_result == 1 else "malware_incorrect"
        else:  # known_status is None
            key = "unknown_benign" if model_result == 0 else "unknown_malware"
        result_summary[key] += count
        result_summary["total_scans"] += count

    if result_summary["total_scans"] > 0:
        accuracy = (
            result_summary["benign_correct"] + result_summary["malware_correct"]
        ) / result_summary["total_scans"]
        result_summary["model_accuracy"] = f"{accuracy:.2%}"

    return result_summary


@app.get("/api/scan-activity-summary")
async def get_scan_activity_summary(_=Depends(get_current_user)):
    pipeline = [
        {
            "$project": {
                "scan_hour": {
                    "$dateToString": {"format": "%Y-%m-%d %H:00", "date": "$scanned_at"}
                }
            }
        },
        {"$group": {"_id": "$scan_hour", "scan_count": {"$sum": 1}}},
        {"$sort": {"_id": 1}},
    ]
    hourly_activity = await FileScan.aggregate(pipeline).to_list(length=None)

    hourly_data = [
        {"scan_hour": record["_id"], "scan_count": record["scan_count"]}
        for record in hourly_activity
    ]
    return hourly_data

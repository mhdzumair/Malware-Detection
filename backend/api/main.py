import logging
from typing import Literal, Optional

from fastapi import FastAPI, HTTPException, Depends, Query
from fastapi import UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.staticfiles import StaticFiles
from sqlalchemy import func
from sqlalchemy.exc import OperationalError
from sqlalchemy.orm import Session

from api import authentication
from api import utils
from api.config import settings
from api.database import get_db
from api.models import FileScan
from api.schemas import TokenData, Token
from defender.model import Model

logging.basicConfig(
    format="%(levelname)s::%(asctime)s - %(message)s",
    datefmt="%d-%b-%y %H:%M:%S",
    level=logging.INFO,
)
app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="authentication")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

model_data = {
    "deep_learning": "defender/saved_models/deep_learning.pkl",
    "random_forest": "defender/saved_models/random_forest.pkl",
}

models = {
    model_name: Model.load(model_path) for model_name, model_path in model_data.items()
}


def get_current_user(
    token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)
):
    credentials_exception = HTTPException(
        status_code=401,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    username = authentication.get_current_user(token)
    if username is None:
        raise credentials_exception
    token_data = TokenData(username=username)

    user = authentication.get_user(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user


@app.post("/authentication", response_model=Token)
def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)
):
    try:
        user = authentication.authenticate_user(
            db, form_data.username, form_data.password
        )
    except OperationalError as error:
        logging.error(error)
        raise HTTPException(status_code=408, detail="Mysql timout error. Retry again.")
    if not user:
        raise HTTPException(
            status_code=401,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token = authentication.create_access_token(
        data={"sub": user.user}, expires_delta=settings.access_token_expire
    )

    return Token(access_token=access_token, token_type="bearer")


@app.post("/scan")
async def scan(
    file: Optional[UploadFile] = None,
    file_url: Optional[str] = None,
    zip_password: Optional[str] = None,
    known_status: Optional[int] = Query(default=None, le=1, ge=0),
    external_tools: bool = None,
    force_rescan: bool = None,
    db: Session = Depends(get_db),
    _=Depends(get_current_user),
):
    # Retrieve file content
    if file_url:
        file_data = utils.download_file_from_url(file_url)
    elif file:
        file_data = await file.read()
    else:
        raise HTTPException(status_code=400, detail="No file or URL provided")

    # Check if the content is a ZIP file and extract if necessary
    if utils.is_zip_file(file_data):
        file_data = utils.extract_zip_file(file_data, zip_password)

    file_hash = utils.compute_file_hash(file_data, "md5")

    # Check if file hash exists in DB
    file_scan = db.query(FileScan).filter(FileScan.md5_file_hash == file_hash).first()
    if file_scan and not force_rescan:
        return {
            "message": "File previously scanned",
            "md5_file_hash": file_scan.md5_file_hash,
            "deep_learning_result": file_scan.deep_learning_result,
            "random_forest_result": file_scan.random_forest_result,
            "external_tool_feedback": file_scan.external_tool_feedback,
            "known_status": file_scan.known_status,
            "scanned_at": file_scan.scanned_at,
        }

    # Scan with models
    try:
        dl_result = models["deep_learning"].predict_files([file_data]).item()
        rf_result = models["random_forest"].predict_files([file_data]).item()
    except Exception as error:
        logging.error(error)
        raise HTTPException(status_code=400, detail=f"Error scanning file: {error}")

    # Get feedback from external tools if requested
    external_feedback = None
    if external_tools:
        try:
            external_feedback, known_status = await utils.get_external_tool_feedback(
                file_data, file_hash
            )
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail=f"Error getting external tool feedback. External tools not configured.",
            )

    if file_scan and force_rescan:
        file_scan.deep_learning_result = dl_result
        file_scan.random_forest_result = rf_result
        file_scan.external_tool_feedback = external_feedback
        file_scan.known_status = known_status
        file_scan.scanned_at = func.now()
        db.commit()
        return_message = "Scan updated"

    else:
        # Store new scan result
        file_scan = FileScan(
            md5_file_hash=file_hash,
            deep_learning_result=dl_result,
            random_forest_result=rf_result,
            external_tool_feedback=external_feedback,
            known_status=known_status,
        )
        db.add(file_scan)
        db.commit()
        return_message = "Scan completed"

    return {
        "message": return_message,
        "md5_file_hash": file_scan.md5_file_hash,
        "deep_learning_result": file_scan.deep_learning_result,
        "random_forest_result": file_scan.random_forest_result,
        "external_tool_feedback": file_scan.external_tool_feedback,
        "known_status": file_scan.known_status,
        "scanned_at": file_scan.scanned_at,
    }


@app.get("/scans")
def list_scans(
    skip: int = 0,
    limit: int = Query(default=100, le=100, ge=1),
    db: Session = Depends(get_db),
    _=Depends(get_current_user),
):
    total_count = db.query(func.count(FileScan.id)).scalar()
    scans = (
        db.query(FileScan)
        .order_by(FileScan.scanned_at.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )
    return {"items": scans, "total": total_count}


@app.get("/scans/{scan_id}")
def get_scan(
    scan_id: int,
    db: Session = Depends(get_db),
    _=Depends(get_current_user),
):
    scan = db.query(FileScan).filter(FileScan.id == scan_id).first()
    if scan is None:
        raise HTTPException(status_code=404, detail="Scan not found")
    return scan


@app.delete("/scans/{scan_id}")
def delete_scan(scan_id: int, db: Session = Depends(get_db)):
    scan = db.query(FileScan).filter(FileScan.id == scan_id).first()
    if scan is None:
        raise HTTPException(status_code=404, detail="Scan not found")
    db.delete(scan)
    db.commit()
    return {"message": "Scan deleted"}


@app.get("/scan-results-summary/{model_type}")
def get_scan_results_summary(
    model_type: Literal["random_forest", "deep_learning"],
    db: Session = Depends(get_db),
    _=Depends(get_current_user),
):
    model_result_column = (
        FileScan.random_forest_result
        if model_type == "random_forest"
        else FileScan.deep_learning_result
    )

    # Aggregate counts for visualization
    query = db.query(
        FileScan.known_status, model_result_column, func.count(FileScan.id)
    ).group_by(FileScan.known_status, model_result_column)
    summary_data = query.all()

    # Transform to a more pie-chart-friendly format
    result_summary = {
        "benign_correct": 0,
        "benign_incorrect": 0,
        "malware_correct": 0,
        "malware_incorrect": 0,
        "unknown_benign": 0,
        "unknown_malware": 0,
        "total_scans": 0,
        "model_accuracy": "N/A",
    }

    for known_status, model_result, count in summary_data:
        if known_status == 0:
            key = "benign_correct" if model_result == 0 else "benign_incorrect"
        elif known_status == 1:
            key = "malware_correct" if model_result == 1 else "malware_incorrect"
        else:  # known_status is None
            key = "unknown_benign" if model_result == 0 else "unknown_malware"
        result_summary[key] += count
        result_summary["total_scans"] += count

    if result_summary["total_scans"] > 0:
        accuracy = (
            result_summary["benign_correct"] + result_summary["malware_correct"]
        ) / result_summary["total_scans"]
        result_summary["model_accuracy"] = f"{accuracy:.2%}"

    return result_summary


@app.get("/scan-activity-summary")
def get_scan_activity_summary(
    db: Session = Depends(get_db), _=Depends(get_current_user)
):
    hourly_activity = (
        db.query(
            func.to_char(FileScan.scanned_at, "YYYY-MM-DD HH24:00").label("scan_hour"),
            func.count().label("scan_count"),
        )
        .group_by("scan_hour")
        .order_by("scan_hour")
        .all()
    )
    hourly_data = [
        {"scan_hour": record.scan_hour, "scan_count": record.scan_count}
        for record in hourly_activity
    ]
    return hourly_data
